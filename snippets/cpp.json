{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"Tokenize string based on delimiters": {
		"prefix": "tokenize",
		"body": [
			"vector<string> tokenize(const string &str, char delimiter) {",
			"  stringstream ss(str);",
			"  string token;",
			"  vector<string> tokens;",
			"  while (getline(ss, token, delimiter)) {",
			"    tokens.push_back(token);",
			"  }",
			"  return tokens;",
			"}",
			"vector<string> tokenize(const string &str) {",
			"  vector<string> tokens;",
			"  regex re(\"[^&=]+\"); // & and = will act as delimiters",
			"  sregex_iterator it(str.begin(), str.end(), re), end;",
			"  while (it != end) {",
			"    tokens.push_back(it->str());",
			"  }",
			"  return tokens;",
			"}"
		],
		"description": "Tokenize string based on delimiters"
	},
	"find adjacent Neighbours in a grid": {
		"prefix": "findNeigh",
		"body": [
			"int dx[4] = {0, 1, 0, -1};",
			"int dy[4] = {1, 0, -1, 0};",
			"vector<pair<int, int>> findNeighbours(int x, int y) {",
			"  vector<pair<int, int>> neighbours;",
			"  for (int i = 0; i < 4; i++) {",
			"    int nx = x + dx[i], ny = y + dy[i];",
			"    if (nx >= 0 && nx < n && ny >= 0 && ny < m && ${1:condition}) {",
			"      neighbours.push_back({nx, ny});",
			"    }",
			"  }",
			"  return neighbours;",
			"}",
			""
		],
		"description": "find adjacent Neighbours in a grid"
	},
	"Modulo Int Datatype": {
		"prefix": "Mint",
		"body": [
			"struct mint {",
			"  ll x;",
			"  mint(ll x = 0) : x((x % MOD + MOD) % MOD) {}",
			"  mint &operator+=(const mint a) {",
			"    if ((x += a.x) >= MOD)",
			"      x -= MOD;",
			"    return *this;",
			"  }",
			"  mint &operator-=(const mint a) {",
			"    if ((x += MOD - a.x) >= MOD)",
			"      x -= MOD;",
			"    return *this;",
			"  }",
			"  mint &operator*=(const mint a) {",
			"    (x *= a.x) %= MOD;",
			"    return *this;",
			"  }",
			"  mint operator+(const mint a) const {",
			"    mint res(*this);",
			"    return res += a;",
			"  }",
			"  mint operator-(const mint a) const {",
			"    mint res(*this);",
			"    return res -= a;",
			"  }",
			"  mint operator*(const mint a) const {",
			"    mint res(*this);",
			"    return res *= a;",
			"  }",
			"  mint pow(ll b) const {",
			"    mint res(1), a(*this);",
			"    while (b) {",
			"      if (b & 1)",
			"        res *= a;",
			"      a *= a;",
			"      b >>= 1;",
			"    }",
			"    return res;",
			"  }",
			"  // for prime MOD",
			"  mint inv() const { return pow(MOD - 2); }",
			"  mint &operator/=(const mint a) { return (*this) *= a.inv(); }",
			"  mint operator/(const mint a) const {",
			"    mint res(*this);",
			"    return res /= a;",
			"  }",
			"};",
			"ostream &operator<<(ostream &os, const mint &a) {",
			"  os << a.x;",
			"  return os;",
			"}",
			"istream &operator>>(istream &is, mint &a) {",
			"  ll val;",
			"  is >> val;",
			"  a = mint(val);",
			"  return is;",
			"}"
		],
		"description": "Modulo Int Datatype"
	},
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
}
