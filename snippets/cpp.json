{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"Tokenize string based on delimiters": {
		"prefix": "tokenize",
		"body": [
			"vector<string> tokenize(const string &str, char delimiter) {",
			"  stringstream ss(str);",
			"  string token;",
			"  vector<string> tokens;",
			"  while (getline(ss, token, delimiter)) {",
			"    tokens.push_back(token);",
			"  }",
			"  return tokens;",
			"}",
			"vector<string> tokenize(const string &str) {",
			"  vector<string> tokens;",
			"  regex re(\"[^&=]+\"); // & and = will act as delimiters",
			"  sregex_iterator it(str.begin(), str.end(), re), end;",
			"  while (it != end) {",
			"    tokens.push_back(it->str());",
			"  }",
			"  return tokens;",
			"}"
		],
		"description": "Tokenize string based on delimiters"
	},
	"find adjacent Neighbours in a grid": {
		"prefix": "findNeigh",
		"body": [
			"int dx[4] = {0, 1, 0, -1};",
			"int dy[4] = {1, 0, -1, 0};",
			"vector<pair<int, int>> findNeighbours(int x, int y) {",
			"  vector<pair<int, int>> neighbours;",
			"  for (int i = 0; i < 4; i++) {",
			"    int nx = x + dx[i], ny = y + dy[i];",
			"    if (nx >= 0 && nx < n && ny >= 0 && ny < m && ${1:condition}) {",
			"      neighbours.push_back({nx, ny});",
			"    }",
			"  }",
			"  return neighbours;",
			"}",
			""
		],
		"description": "find adjacent Neighbours in a grid"
	},
	"Finds all divisors from prime factorization in O(no. of divisors) or given Number in O(sqrt(n))": {
		"prefix": "FindDivisors",
		"body": [
			"vector<int> divisors;",
			"void dfs(int idx, int curr, const vector<pair<int, int>> &factors) {",
			"  // find all divisors in O(no. of divisors) if prime factorization already",
			"  // given",
			"  if (idx == factors.size()) {",
			"    divisors.push_back(curr);",
			"    return;",
			"  }",
			"  int p = factors[idx].first;",
			"  int e = factors[idx].second;",
			"  for (int i = 0, val = 1; i <= e; ++i) {",
			"    dfs(idx + 1, curr * val, factors);",
			"    val *= p;",
			"  }",
			"}",
			"void findDivisors(const vector<pair<int, int>> &primeFactors) {",
			"  dfs(0, 1, primeFactors);",
			"  sort(divisors.begin(), divisors.end());",
			"}",
			"void findDivisors(int n) {",
			"  for (int i = 1; i * i <= n; i++) {",
			"    if (n % i == 0) {",
			"      divisors.push_back(i);",
			"      if (i * i != n)",
			"        divisors.push_back(n / i);",
			"    }",
			"  }",
			"  sort(divisors.begin(), divisors.end());",
			"}"
		],
		"description": "Finds all divisors from prime factorization in O(no. of divisors) or given Number in O(sqrt(n))"
	},
	"Find primes in nloglogn for 1e6": {
		"prefix": "sieve",
		"body": [
			"vector<bool> is_prime;",
			"vector<int> primes;",
			"void sieve(int n) {",
			"  is_prime.assign(n + 1, true);",
			"  is_prime[0] = is_prime[1] = false;",
			"  // only checks till root n, so lesser computations",
			"  for (int i = 2; i * i <= n; i++) {",
			"    if (is_prime[i]) {",
			"      primes.push_back(i);",
			"      // skips elements less than i*i, since already marked by smaller factors",
			"      for (int j = i * i; j <= n; j += i)",
			"        is_prime[j] = false;",
			"    }",
			"  }",
			"}"
		],
		"description": "Find primes in nloglogn"
	},
	"Find Primes for 1e7(skips even numbers as well)": {
		"prefix": "sieveOptimized",
		"body": [
			"vector<bool> is_prime;",
			"vector<int> primes;",
			"void sieve(int n) {",
			"  is_prime.assign(n + 1, true);",
			"  is_prime[0] = is_prime[1] = false;",
			"  if (n >= 2) {",
			"    is_prime[2] = true;",
			"    primes.push_back(2);",
			"  }",
			"  for (int i = 4; i <= n; i += 2)",
			"    is_prime[i] = false;",
			"  for (int i = 3; i * i <= n; i += 2) {",
			"    if (is_prime[i]) {",
			"      primes.push_back(i);",
			"      for (int j = i * i; j <= n; j += 2 * i)",
			"        is_prime[j] = false;",
			"    }",
			"  }",
			"}"
		],
		"description": "skips even numbers as well"
	},
	"Linear Sieve and logN factorization": {
		"prefix": "LinearSieve",
		"body": [
			"vector<int> primes;",
			"vector<int> lowestPrimeFactor;",
			"void linearSieve(int n) { // O(n)",
			"  lowestPrimeFactor.assign(n + 1, 0);",
			"  for (int i = 2; i <= n; ++i) {",
			"    if (lowestPrimeFactor[i] == 0) {",
			"      lowestPrimeFactor[i] = i;",
			"      primes.push_back(i);",
			"    }",
			"    for (int j = 0; i * primes[j] <= n; ++j) {",
			"      lowestPrimeFactor[i * primes[j]] = primes[j];",
			"      if (primes[j] == lowestPrimeFactor[i]) {",
			"        break;",
			"      }",
			"    }",
			"  }",
			"}",
			"vector<int> factorize(int num) { // O(logn)",
			"  vector<int> ans;",
			"  while (num > 1) {",
			"    ans.push_back(lowestPrimeFactor[num]);",
			"    num /= lowestPrimeFactor[num];",
			"  }",
			"  return ans;",
			"}"
		],
		"description": "Linear Sieve and logN factorization"
	},
	"Deterministic Prime number test for 64 bit numbers": {
		"prefix": "MillerRabin",
		"body": [
			"using u64 = uint64_t;",
			"using u128 = __uint128_t;",
			"u64 binpower(u64 base, u64 e, u64 mod) {",
			"  u64 result = 1;",
			"  base %= mod;",
			"  while (e) {",
			"    if (e & 1)",
			"      result = (u128)result * base % mod;",
			"    base = (u128)base * base % mod;",
			"    e >>= 1;",
			"  }",
			"  return result;",
			"}",
			"bool check_composite(u64 n, u64 a, u64 d, int s) {",
			"  u64 x = binpower(a, d, n);",
			"  if (x == 1 || x == n - 1)",
			"    return false;",
			"  for (int r = 1; r < s; r++) {",
			"    x = (u128)x * x % n;",
			"    if (x == n - 1)",
			"      return false;",
			"  }",
			"  return true;",
			"}",
			"// returns true if n is prime, else returns false.",
			"bool MillerRabin(u64 n) { // O(logn) per number",
			"  if (n < 2)",
			"    return false;",
			"",
			"  int r = 0;",
			"  u64 d = n - 1;",
			"  while ((d & 1) == 0) {",
			"    d >>= 1;",
			"    r++;",
			"  }",
			"  // for 32 bit numbers only use first 4 bases",
			"  for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
			"    if (n == a)",
			"      return true;",
			"    if (check_composite(n, a, d, r))",
			"      return false;",
			"  }",
			"  return true;",
			"}"
		],
		"description": "Deterministic Prime number test for 64 bit numbers"
	},
	"gcd to diophantine to CRT": {
		"prefix": "maths",
		"body": [
			"int euclideanGcd(int a, int b, int &x, int &y) {",
			"  if (b == 0) {",
			"    x = 1;",
			"    y = 0;",
			"    return a;",
			"  }",
			"  int x1, y1;",
			"  int d = euclideanGcd(b, a % b, x1, y1);",
			"  x = y1;",
			"  y = x1 - y1 * (a / b);",
			"  return d;",
			"}",
			"int lcm(int a, int b) { return (a / gcd(a, b)) * b; }",
			"bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
			"  g = euclideanGcd(abs(a), abs(b), x0, y0);",
			"  if (c % g) {",
			"    return false;",
			"  }",
			"  x0 *= c / g;",
			"  y0 *= c / g;",
			"  if (a < 0)",
			"    x0 = -x0;",
			"  if (b < 0)",
			"    y0 = -y0;",
			"  return true;",
			"}",
			"void shift_solution(int &x, int &y, int a, int b, int cnt) {",
			"  x += cnt * b;",
			"  y -= cnt * a;",
			"}",
			"int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny,",
			"                       int maxy, int &x, int &y) {",
			"  // returns total no of solutions within bound and also one pair of(x,y) values",
			"  // with minimal x and corresponding y",
			"  int g;",
			"  if (!find_any_solution(a, b, c, x, y, g))",
			"    return 0;",
			"  a /= g;",
			"  b /= g;",
			"",
			"  int sign_a = a > 0 ? +1 : -1;",
			"  int sign_b = b > 0 ? +1 : -1;",
			"",
			"  shift_solution(x, y, a, b, (minx - x) / b);",
			"  if (x < minx)",
			"    shift_solution(x, y, a, b, sign_b);",
			"  if (x > maxx)",
			"    return 0;",
			"  int lx1 = x;",
			"  shift_solution(x, y, a, b, (maxx - x) / b);",
			"  if (x > maxx)",
			"    shift_solution(x, y, a, b, -sign_b);",
			"  int rx1 = x;",
			"",
			"  shift_solution(x, y, a, b, -(miny - y) / a);",
			"  if (y < miny)",
			"    shift_solution(x, y, a, b, -sign_a);",
			"  if (y > maxy)",
			"    return 0;",
			"  int lx2 = x;",
			"",
			"  shift_solution(x, y, a, b, -(maxy - y) / a);",
			"  if (y > maxy)",
			"    shift_solution(x, y, a, b, sign_a);",
			"  int rx2 = x;",
			"",
			"  if (lx2 > rx2)",
			"    swap(lx2, rx2);",
			"  int lx = max(lx1, lx2);",
			"  int rx = min(rx1, rx2);",
			"  if (lx > rx)",
			"    return 0;",
			"  return (rx - lx) / abs(b) + 1;",
			"}",
			""
		],
		"description": "gcd to diophantine to CRT"
	},
	"Modulo Int Datatype": {
		"prefix": "Mint",
		"body": [
			"#define ll long long",
			"struct mint {",
			"  ll x;",
			"  mint(ll x = 0) : x((x % MOD + MOD) % MOD) {}",
			"  mint &operator+=(const mint a) {",
			"    if ((x += a.x) >= MOD)",
			"      x -= MOD;",
			"    return *this;",
			"  }",
			"  mint &operator-=(const mint a) {",
			"    if ((x += MOD - a.x) >= MOD)",
			"      x -= MOD;",
			"    return *this;",
			"  }",
			"  mint &operator*=(const mint a) {",
			"    (x *= a.x) %= MOD;",
			"    return *this;",
			"  }",
			"  mint operator+(const mint a) const {",
			"    mint res(*this);",
			"    return res += a;",
			"  }",
			"  mint operator-(const mint a) const {",
			"    mint res(*this);",
			"    return res -= a;",
			"  }",
			"  mint operator*(const mint a) const {",
			"    mint res(*this);",
			"    return res *= a;",
			"  }",
			"  mint pow(ll b) const {",
			"    mint res(1), a(*this);",
			"    while (b) {",
			"      if (b & 1)",
			"        res *= a;",
			"      a *= a;",
			"      b >>= 1;",
			"    }",
			"    return res;",
			"  }",
			"  // for prime MOD",
			"  mint inv() const { return pow(MOD - 2); }",
			"  mint &operator/=(const mint a) { return (*this) *= a.inv(); }",
			"  mint operator/(const mint a) const {",
			"    mint res(*this);",
			"    return res /= a;",
			"  }",
			"};",
			"ostream &operator<<(ostream &os, const mint &a) {",
			"  os << a.x;",
			"  return os;",
			"}",
			"istream &operator>>(istream &is, mint &a) {",
			"  ll val;",
			"  is >> val;",
			"  a = mint(val);",
			"  return is;",
			"}"
		],
		"description": "Modulo Int Datatype"
	},
	"binary exponentiation under modulo": {
		"prefix": "binpow",
		"body": [
			"long long binpow(long long a, long long b) {",
			"  long long res = 1;",
			"  while (b > 0) {",
			"    if (b & 1)",
			"      res = res * a;",
			"    a = a * a;",
			"    b >>= 1;",
			"  }",
			"  return res;",
			"}",
			"long long binpow(long long a, long long b, long long m) {",
			"  a %= m;",
			"  long long res = 1;",
			"  while (b > 0) {",
			"    if (b & 1)",
			"      res = res * a % m;",
			"    a = a * a % m;",
			"    b >>= 1;",
			"  }",
			"  return res;",
			"}",
			"long long binpow(long long a, long long b, long long c, long long m) {",
			"  if (b == 0 && c > 0)",
			"    return 1; // but mathematically 0^0 is undefined",
			"  if (a % m == 0)",
			"    return 0;",
			"  int p = binpow(b, c, m - 1);",
			"  return binpow(a, p, m);",
			"}",
			"int inverse(int a, int mod) { return binpow(a, mod - 2, mod); }"
		],
		"description": "binary exponentiation under modulo"
	},
	"ncr precomputation (n,r<=1e6) O(n+logn) precomputation with O(1) query": {
		"prefix": "ncr1e6",
		"body": [
			"long long binpow(long long a, long long b) {",
			"  long long res = 1;",
			"  while (b > 0) {",
			"    if (b & 1)",
			"      res = res * a;",
			"    a = a * a;",
			"    b >>= 1;",
			"  }",
			"  return res;",
			"}",
			"long long binpow(long long a, long long b, long long m) {",
			"  a %= m;",
			"  long long res = 1;",
			"  while (b > 0) {",
			"    if (b & 1)",
			"      res = res * a % m;",
			"    a = a * a % m;",
			"    b >>= 1;",
			"  }",
			"  return res;",
			"}",
			"long long binpow(long long a, long long b, long long c, long long m) {",
			"  if (b == 0 && c > 0)",
			"    return 1; // but mathematically 0^0 is undefined",
			"  if (a % m == 0)",
			"    return 0;",
			"  int p = binpow(b, c, m - 1);",
			"  return binpow(a, p, m);",
			"}",
			"int inverse(int a, int m) { return binpow(a, m - 2, m); }",
			"",
			"vector<int> fact, inv_fact;",
			"void factorials(int n, int m) {",
			"  fact.assign(n + 1, 0);",
			"  inv_fact.assign(n + 1, 0);",
			"  fact[0] = 1;",
			"  for (int i = 1; i <= n; i++)",
			"    fact[i] = (fact[i - 1] * i) % m;",
			"  inv_fact[n] = binpow(fact[n], m - 2, m);",
			"  for (int i = n - 1; i >= 0; i--) {",
			"    inv_fact[i] = ((i + 1) * inv_fact[i + 1]) % m;",
			"  }",
			"}",
			"int ncr(int n, int r, int m) {",
			"  return (fact[n] * ((inv_fact[r] * inv_fact[n - r]) % m)) % m;",
			"}"
		],
		"description": "ncr precomputation O(n+logn) precomputation with O(1) query"
	},
	"ncr precomputation (n,r<=1000)": {
		"prefix": "ncr1000",
		"body": [
			"vector<vector<int>> ncr;",
			"void precomputencr(int m) {",
			"  int mxn = 1001, mxr = 1001;",
			"  ncr.assign(mxn, vector<int>(mxr, 0));",
			"  for (int n = 0; n <= mxn; n++) {",
			"    for (int r = 0; r <= n; r++) {",
			"      if (r == 0 || r == n) {",
			"        ncr[n][0] = 1;",
			"      }",
			"      ncr[n][r] = (ncr[n - 1][r - 1] + ncr[n - 1][r]) % m;",
			"    }",
			"  }",
			"}"
		],
		"description": "ncr precomputation without modulo (n,r<=1000)"
	},
	"Create a 1-based 2D prefix sum for a given 0-based grid": {
		"prefix": "prefixSum2D",
		"body": [
			"struct prefixSum2D { // this needs a zero based grid and supports queries in one",
			"                     // based",
			"  vector<vector<int>> pref;",
			"  prefixSum2D(vector<vector<int>> v) {",
			"    int n = v.size(), m = v[0].size();",
			"    pref.assign(n + 1, vector<int>(m + 1, 0));",
			"    for (int i = 1; i <= n; i++) {",
			"      for (int j = 1; j <= m; j++) {",
			"        pref[i][j] = v[i - 1][j - 1] + pref[i - 1][j] + pref[i][j - 1] -",
			"                     pref[i - 1][j - 1];",
			"      }",
			"    }",
			"  }",
			"  int query(int ulx, int uly, int size) {",
			"    int brx = ulx + size, bry = uly + size;",
			"    return query(ulx, uly, brx, bry);",
			"  }",
			"  int query(int ulx, int uly, int brx, int bry) {",
			"    return pref[brx][bry] + pref[ulx - 1][uly - 1] - pref[brx][uly - 1] -",
			"           pref[ulx - 1][bry];",
			"  }",
			"};"
		],
		"description": "Create a 1-based 2D prefix sum for a given 0-based grid"
	},
	"Handles queries for 2D partial sum": {
		"prefix": "partialSum2D",
		"body": [
			"void partialSum2D() {",
			"    int n, m, q;",
			"    cin >> n >> m >> q;",
			"    // cout << q << endl;",
			"    int sum = 0;",
			"    vector<vector<int>> v(n + 2, vector<int>(m + 2, 0));",
			"    while (q--) {",
			"      // increase all cells having upper left x1,y1 and bottom right x2,y2 by a",
			"      // value c",
			"      int x1, y1, x2, y2, c;",
			"      cin >> x1 >> y1 >> x2 >> y2 >> c;",
			"      v[x1][y1] += c;",
			"      v[x1][y2 + 1] -= (c);",
			"      v[x2 + 1][y1] -= (c);",
			"      v[x2 + 1][y2 + 1] += c;",
			"    }",
			"  }"
		],
		"description": "Handles queries for 2D partial sum"
	}
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
}
